1. 一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件通过内部总线相连。相对于CPU内部总线来说，其他的称为外部总线。内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上的其他器件之间的联系。

2. 在CPU中：

   1. 运算器进行信息处理
   2. 寄存器进行信息存储
   3. 控制器控制各种器件进行工作
   4. 内部总线连接各种器件，在它们之间传送数据

3. 不同的CPU，寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称，这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。8086CPU的所有寄存器都是16位的，可以存放2个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容性，使原来基于上代CPU编写的程序稍加修改即可运行在8086上，8086CPU的AX、BX、CX、DX这4个寄存器都可以分为两个可独立使用的8位寄存器。

   * AX可分为AH和AL
   * BX可分为BH和BL
   * CX可分为CH和CL
   * DX可分为DH和DL

4. 在进行数据传送或运算的时候，要注意指令的两个操作对象的位数应当一致，例如：

   ```assembly
   mov ax,bx
   mov bx,cx
   mov ax,18H
   mov al,18H
   add ax,bx
   add ax,20000
   ```

   如下述指令，则皆为错误指令：

   ```assembly
   mov ax,bl         # 在8位寄存器和16位寄存器之间传送数据
   mov bh,ax         # 在16位寄存器和8位寄存器之间传送数据
   mov al,20000      # 8位寄存器最大可存放的数值为255的数据
   add al,100H       # 将一个大于8位的数据加到8位寄存器中
   ```

5. CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间内都有唯一的地址，称为物理地址。

6. CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线发出物理地址之前，必须要在内部先形成这个物理地址。

7. 8086CPU的上一代CPU（8080、8085）等是8位机，而8086是16位机。也可以说8086是16位结构的CPU，它包括以下几方面的结构特性：

   1. 运算器一次最多可以处理16位的数据
   2. 寄存器的最大宽度为16位
   3. 寄存器和运算器之间的通路为16位。

8. 8086有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU内部结构来看，如果将地址从内部简单的发出，那它只能传送16位的地址，表现出的寻址能力为64KB。8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

   ![image-20210407160056636](E:\读书笔记\汇编语言\images\图2.6 8086CPU相关部件的逻辑结构.png)

9. 当8086CPU要读写内存时：

   1. CPU中的相关部件提供两个16位的地址，一个称为段地址，一个称为偏移地址。
   2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。
   3. 地址加法器将两个16位地址合成一个20位的物理地址。
   4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路
   5. 输入输出控制电路将20位物理地址送上地址总线。
   6. 20位物理地址被地址总线传送到存储器。

10. 地址加法器采用<b>物理地址 = 基础地址（段地址 x 16） + 偏移地址</b>的方法合成物理地址。

    ![image-20210407160208267](E:\读书笔记\汇编语言\images\图2.7 地址加法器的工作过程.png)

11. 实际上，内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地址 + 偏移地址 = 物理地址”的方式来给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。如图，我们可以认为：地址10000H\~100FFH的内存单元组成一个段，该段的起始地址为10000H，段地址为1000H，大小为100H，我们也可以认为地址10000H\~1007FH、10080H\~100FFH的内存单元组成两个段，它们的起始地址为：10000H和10080H，段地址为1000H和1008H，大小都为80H。

    ![image-20210407161520917](E:\读书笔记\汇编语言\images\图2.9 分段.png)

    需要注意的是，段地址 x 16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB。

12. CPU可以使用不同的段地址和偏移地址形成同一个物理地址。

13. CS和IP是8086CPU中两个最关键的寄存器，**它们指示了CPU当前要读取指令的地址**。CS为代码段寄存器，IP为指令指针寄存器。在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M x 16 + N单元开始，读取一条指令并执行。

    ![image-20210407162706588](E:\读书笔记\汇编语言\images\图2.10 8086PC读取和执行指令的相关部件.png)

    由上图可知，8086CPU的工作过程简述如下：

    * 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区
    * IP = IP + 所读取指令的长度，从而指向下一条指令
    * 执行指令。转到步骤1，重复。

    在8086CPU加电启动或者复位后，CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机启动时，CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

14. 8086CPU中大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。但是mov指令不能用于设置CS、IP的值。8086CPU为CS、IP提供了另外的指令来修改它们的值，能够改变CS、IP内容的指令被称为转移指令，比如jmp指令。

    若想同时修改CS、IP的内容，可用形如“jmp 段地址:偏移地址”的指令完成，如

    ```assembly
    jmp 2AE3:3 # 执行后，CS=2AE3,IP=0003
    jmp 3:0B16 # 执行后，CS=0003,IP=0B16
    ```

    若想仅修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成，如：

    ```assembly
    jmp ax 
    jmp bx
    ```

15. 对于8086PC机，在编程时，可根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N <= 64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个<b>代码段</b>。将一段内存当作代码段，仅仅是编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。所以，要让CPU执行我们放在代码段的指令，需要将CS:IP指向所定义的代码段的第一条指令的首地址。























