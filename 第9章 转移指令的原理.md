1. 可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令就是可以控制CPU执行内存中某处代码的指令。

2. 8086CPU的转义行为有以下几类：

   1. 只修改IP时，称为段内转移，比如：jmp ax。
   2. 同时修改CS和IP时，称为段间转移，比如：jmp 1000:0

3. 由于转移指令对IP的修改范围不同，段内转义又分为短转移和近转移。

   1. 短转移IP的修改范围是-128~127。
   2. 近转移IP的修改范围是-32768~32767

4. 8086CPU的转移指令分为以下几类：

   1. 无条件转移指令（如jmp）
   2. 条件转移指令
   3. 循环指令（如loop）
   4. 过程
   5. 中断

   这些转移指令的前提条件可能不同，但是转移的基本原理是相同的。

5. 操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

   ```assembly
   assume cs:code
   code segment
   	start:mov ax,offset start
   	s:mov ax,offset s
   code ends
   end start
   ```

6. jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。jmp指令给出两种信息：

   1. 转移的目的地址
   2. 转移的距离（段间转移、段内短转移、段内近转移）

7. 依据位移进行转移的jmp指令

   ```assembly
   jmp short 标号（转到标号处执行指令）
   ```

   这种格式的jmp实现的是段内短转移，它对IP的修改范围是-128~127，short代表指令进行的是短转移。该指令对应的机器码中，并不包含转移的目的地址，而是包含的转移的位移。

8. “jmp short 标号”的功能为(IP)=(IP) + 8位位移。

   1. 8位位移=标号处的地址 - jmp指令后的第一个字节的地址。
   2. short指明此处的位移是8位位移。
   3. 8位位移的范围是-128~127，用补码表示。
   4. 8位位移由编译器在编译时算出。

9. “jmp near ptr 标号”的功能为：(IP)=(IP)+16位位移。

   1. 16位位移=标号处的地址-jmp指令后的第一个字节的地址。
   2. near ptr指明此处的位移是16位位移，进行的是段内近位移。
   3. 16位位移的范围是-32768~32767，补码表示。
   4. 16位位移由编译器在编译时算出。

10. 依据目的地址转移的jmp指令：

    ```assembly
    jmp far ptr 标号
    ```

    实现的是段间转移，又称为远转移。功能如下：

    (CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

    ```assembly
    assume cs:code
    
    code segment
    start:	mov ax,0
    		jmp far ptr s
    		db 256 dump(0)
    		
    	s: 	add ax,1
    		inc ax
    		
    		mov ax,4c00H
    		int 21H
    code ends
    end start
    ```

11. 转移地址在寄存器中的jmp指令

    格式：jmp 16位reg

    功能：(IP)=(16位reg)

12. 转移地址在内存中的jmp指令

    1. jmp word ptr 内存单元地址（段内转移）

       功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。

       ```assembly
       mov ax,0123H
       mov ds:[0],ax
       jmp word ptr ds:[0]
       
       ;
       mov ax,0123H
       mov [bx],ax
       jmp word ptr [bx]
       ```

    2. jmp dword ptr 内存单元地址（段间转移）

       功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

       (CS)=(内存单元地址+2)

       (IP)=(内存单元地址)

       ```assembly
       mov ax,0123H
       mov ds:[0],ax
       mov word ptr ds:[2],0
       jmp dword ptr ds:[0]
       
       ;
       
       mov ax,0123H
       mov [bx],ax
       mov word ptr [bx+2],0
       jmp dword ptr [bx]
       ```

13. jcxz指令为有条件转移指令，所有的有条件指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围是-128~127。

    1. 指令格式：jcxz 标号（如果(cx)=0,转移到标号处执行）
    2. 操作：当(cx)=0，(IP)=(IP)+8位位移；
    3. 8位位移=标号处的地址 - jcxz指令后的第一个字节的地址
    4. 8位位移的范围是-128~127，用补码表示。
    5. 8位位移由编译程序在编译时算出。

14. loop指令为循环指令，所有的循环指令都是短转移。
    
    1. 指令格式：loop 标号（(cx)=(cx)-1,如果(cx) != 0，转移到标号处执行）
    2. 操作：(cx)=(cx)-1
    3. 8位位移=标号处的地址 - loop指令后的第一个字节的地址；
    4. 8位位移的范围是-128~127，用补码表示。
    5. 8位位移由编译程序在编译时算出。
    6. 如果(cx)=0，什么也不做。
    
15. 根据位移进行转移的意义

    ```assembly
    jmp short 标号
    jmp near ptr 标号
    jcxz 标号
    loop 标号
    ```

    这些汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的，这种设计，方便了程序段在内存中的浮动装配。

16. 根据位移进行转移的指令，它们的转移范围收到转移位移的限制，如果在源程序中出现了转移范围越界的问题，在编译的时候，编译器将报错。

​    

​    

​    


  















