1. CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086CPU有一个DS寄存器，**通常用来存放要访问的数据的段地址**。比如

   ```assembly
   mov bx,1000H
   mov ds,bx
   mov al,[0]
   ```

   “[...]”表示一个内存单元，“[...]”中的0表示内存单元的偏移地址。执行指令时，8086CPU自动取ds中的数据为内存单元的段地址。**8086CPU不支持将数据直接送入段寄存器的操作**，ds是一个段寄存器，所以mov ds,1000H这条指令是非法的。只能通过一个普通的寄存器，将数据送入，再将普通寄存器的数据送入段寄存器。

2. 将数据从寄存器送入内存（字节）

   ```assembly
   mov bx,1000H
   mov ds,bx
   mov [0],al
   ```

3. 将一段内存当作数据段，是在编程时的一种安排。可以在操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

4. 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低字节放在低地址单元，高位字节放在高地址单元。

5. 用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。

6. 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。

7. mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。

8. 8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。比如，push ax表示将寄存器ax中的数据送入栈中，pop ax表示从栈中取出数据送入ax。**8086CPU的入栈和出栈操作都是以字为单位进行的。**

9. 在8086CPU中，有两个寄存器，栈段寄存器SS和栈指针寄存器SP，栈顶的段地址存放在SS中，偏移地址放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。

10. push ax的执行，由以下两步完成：

    1. SP = SP- 2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。
    2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

11. pop ax的执行过程，由以下两步完成：

    1. 将SS:SP指向的内存单元处的数据送入ax。
    2. SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

12. 8086CPU不保证对栈的操作不会越界。8086CPU只知道栈顶在何处（由SS:SP指示），而不知道我们安排的占空间有多大。

13. push和pop指令不同于mov指令，mov指令只需一个操作，就是传送；而push和pop指令却是两个操作。执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送；执行pop时，CPU的操作是：先读取SS:SP处的数据，后改变SP。需要注意的是，push、pop等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大是：0~FFFFH。

14. 栈段：可以根据需要，将一组内存单元定义为一个段，我们可以将长度为N（N <= 64KB）的一组连续、起始地址为16的倍数的内存单元，当作占空间来用，从而定义了一个栈段。

15. 可以将一段内存定义成一个段，用一个段地址指示段，用偏移地址访问段内的单元。这由我们自己定义：

    1. 可以用一个段存放数据，将它定义为“数据段”。
    2. 可以用一个段存放代码，将它定义为“代码段”。
    3. 可以用一个段当作栈，将它定义为“栈段”。

    对于数据段，将它的段地址放在DS寄存器中，用mov，add，sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问。

    对于代码段，将它的段地址放在CS寄存器中，将段中第一条指令的偏移地址放在IP寄存器中，这样CPU就将执行我们定义的代码段中的指令。

    对于栈段，将它的段地址放在SS寄存器中，将栈顶单元的偏移地址放在SP中，这样CPU在需要执行栈操作的时候，就将我们定义的栈段当作栈空间来使用。























