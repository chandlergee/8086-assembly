1. 标志寄存器的作用：

   1. 用来存储相关指令的某些执行结果
   2. 用来为CPU执行相关指令提供行为依据
   3. 用来控制CPU的相关工作方式

2. 8086CPU的标志寄存器有16位，其中存储的信息被称为程序状态字（PSW）。程序状态字寄存器中的每一位，都有专门的含义，记录特定的信息。

   | 比特位 | 作用 | 比特位 | 作用 |
   | ------ | ---- | ------ | ---- |
   | bit0   | CF   | bit1   | 保留 |
   | bit2   | PF   | bit3   | 保留 |
   | bit4   | AF   | bit5   | 保留 |
   | bit6   | ZF   | bit7   | SF   |
   | bit8   | TF   | bit9   | IF   |
   | bit10  | DF   | bit11  | OF   |
   | bit12  | 保留 | bit13  | 保留 |
   | bit14  | 保留 | bit15  | 保留 |

3. ZF（bit6），零标志位，它记录相关指令执行后，其结果是否为0。如果结果为0，那么zf=1，如果结果不为0，那么zf=0。

4. PF（bit2），奇偶标志位，它记录相关指令执行后，其结果所在bit位中1的个数是否为偶数，如果为偶数，pf=1，如果为奇数，pf=0。

5. SF（bit7），符号标志位，它记录相关指令执行后，其结果是否为负。如果为负，sf=1，否则sf=0。

   SF标志，是CPU对有符号数运算结果的一种记录，它记录数据的正负。当把数据当作有符号数来运算时，可以通过它来得知结果的正负。如果将数据当作无符号数来运算，SF的值就没有意义。

6. CF（bit0），在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

   ![image-20210420132643185](E:\读书笔记\汇编语言\images\更高位.png)

   两个数相加的时候，有可能产生从最高有效位向更高位的进位。比如，两个8位数据：`98H+98H`，将产生进位。由于进位值在8位数中无法保存，所有将其记录在CF中。

   ```assembly
   mov al,98H
   add al,al ;执行后，(al)=30H,CF=1
   add al,al ;执行后，(al)=60H,CF=0
   ```

   当两个数做减法的时候，有可能向更高位借位。比如，两个8位数据`97H-98H`，将产生借位，借位后，相当于计算`197H-98H`。而CF位可以用来记录这个借位值。

   ```assembly
   mov al,97H
   sub al,98H ;执行后，(al)=FFH,CF=1
   sub al,al ;执行后，(al)=0,CF=0
   ```

7. 在进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为**溢出**。

8. OF（bit11）,溢出标志位，一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生了溢出，OF=1；否则，OF=0。

9. CF和OF的区别在于：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。

10. adc是带进位加法指令，它利用CF位上记录的进位值。

    指令格式：adc  操作对象1,操作对象2

    功能：操作对象1 = 操作对象1 + 操作对象2 + CF

    ```assembly
    mov ax,2
    mov bx,1
    sub bx,ax
    adc ax,1
    ;执行后，(ax)=4,adc执行时，相当于：(ax)+1+CF=2+1+1=4
    
    mov ax,1
    add ax,ax
    adc ax,3
    ;执行后，(ax)=5。adc执行时，相当于：(ax)+3+CF=2+3+0=5
    ```

    adc指令比add指令多加了一个CF位的值。

11. 在执行adc指令的时候加上的CF的值的含义，是由adc指令前面的指令决定的，即关键在于加上的CF值是被什么指令设置的。如果CF的值是被sub指令设置的，那它的含义就是借位；如果CF的值是被add指令设置的，那么它的含义就是进位值。

12. 对于两个数0198H和0183H的加法，可以分为两步来进行：

    1. 低位相加
    2. 高位相加再加上低位相加产生的进位值。

    所以下面的指令和`add ax,bx`具有相同的结果

    ```assembly
    add al,bl
    adc ah,bh
    ```

13. 计算`1EF000H+201000H`，结果放在ax（高16位）和bx（低16位）中。

    ```assembly
    mov ax,001EH
    mov bx,0F000H
    add bx,1000H
    adc ax,0020H
    ```

14. 计算`1EF0001000H+2010001EF0H`，结果放在ax（最高16位）、bx（次高16位）和cx（低16位）中。

    1. 先将低16位相加，完成后，CF中记录本次相加的进位值。
    2. 再将次高16位和CF相加，完成后，CF中记录本次相加的进位值。
    3. 最后高16位和CF相加，完成后，CF中记录本次相加的进位值。

    ```assembly
    mov ax,001EH
    mov bx,0F000H
    mov cx,1000H
    add cx,1EF0H
    adc bx,1000H
    adc ax,0020H
    ```

15. sbb是带借位减法指令，它利用CF位上记录的借位值。

    指令格式：sbb 操作对象1,操作对象2

    功能：操作对象1 = 操作对象1 - 操作对象2 - CF

    比如指令`sbb ax,bx`实现的功能是：(ax)=(ax)-(bx)-CF

    sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。比如，计算`003E1000H-00202000H`，结果放在ax,bx中：

    ```assembly
    mov bx,1000H
    mov ax,003EH
    sub bx,2000H
    sbb ax,0020H
    ```

16. cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。cmp指令格式：`cmp 操作对象1,操作对象2`。

17. cmp指令通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果。对于`cmp ax,bx`：

    1. 如果(ax) = (bx)，则(ax) - (bx) = 0，所以zf=1；
    2. 如果(ax) !=(bx)，则(ax) - (bx) != 0，所以zf = 0；
    3. 如果(ax) < (bx)，则(ax) - (bx)将产生借位，所以：cf=1
    4. 如果(ax)>=(bx)，则(ax) - (bx)不必借位，cf=0
    5. 如果(ax)>(bx)，则(ax)-(bx)既不必借位，结果又不为0，所以cf=0且zf=0
    6. (ax)<=(bx)，则(ax)-(bx)既可能借位，结果又可能为0，所以，cf=1或zf=1

18. 对于无符号数，指令`cmp ax,bx`的逻辑含义是比较ax和bx的值，如果执行后：

    1. zf=1，说明(ax)=(bx)
    2. zf=0，说明(ax)!=(bx)
    3. cf=1，说明(ax)<(bx)
    4. cf=0，说明(ax)>=(bx)
    5. cf=0且zf=0，说明(ax)>(bx)
    6. cf=1或zf=1，说明(ax)<=(bx)

19. 对于有符号数，指令`cmp ah,bh`，同样是比较大小：

    1. 如果zf=1，则(ah)=(bh)
    2. 如果zf=0，则(ah)!=(bh)
    3. 如果sf=1，of=0，则(ah)<(bh)
    4. 如果sf=1，of=1，则(ah)>(bh)
    5. 如果sf=0，of=1，则(ah)<(bh)
    6. 如果sf=0，of=0，则(ah)>=(bh)

20. 常用的根据无符号数的比较结果进行转移的条件转移指令：

    | 指令 | 含义         | 检测的相关标志位 |
    | ---- | ------------ | ---------------- |
    | je   | 等于则转移   | zf=1             |
    | jne  | 不等于则转移 | zf=0             |
    | jb   | 低于则转移   | cf=1             |
    | jnb  | 不低于则转移 | cf=0             |
    | ja   | 高于则转移   | cf=0且zf=0       |
    | jna  | 不高于则转移 | cf=1或zf=1       |

    ```assembly
       cmp ah,bh
       je s
       add ah,bh
       jmp short ok
     s:add ah,ah
    ok:...
    ```

21. 标志寄存器的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减：

    1. df=0，每次操作后，si、di递增。
    2. df=1，每次操作后，si、di递减。

22. 串传送指令movsb：

    格式：movsb

    功能：执行movsb指令相当于下面几个步骤。

    1. `((es) * 16 + (di)) = ((ds) * 16 + (si))`
    2. 如果df=0，`(si)=(si)+1;(di)=(di)+1`
    3. 如果df=1，`si)=(si)-1;(di)=(di)-1`

23. movsw的功能是将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。

24. 8086CPU提供两个指令对df位进行设置

    1. cld指令：将标志寄存器的df位设置为0
    2. std指令：将标志寄存器的df位设置为1

25. pushf的功能是将标志寄存器中的值压栈，而popf是从栈中弹出数据，送入标志寄存器。

    ```assembly
    mov ax,0
    push ax
    popf
    mov ax,0fff0H
    add ax,0010H
    pushf
    pop ax
    add al,11000101B
    add ah,00001000B
    ```

    















